/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package view;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;

import javax.swing.*;
import java.awt.*;
import org.jfree.chart.labels.StandardCategoryItemLabelGenerator;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.renderer.category.LineAndShapeRenderer;
import org.jfree.data.category.DefaultCategoryDataset;
import org.jfree.data.general.DefaultPieDataset;

import javax.swing.table.DefaultTableModel;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;
import java.util.Map;

/**
 * Classe responsável por analisar os gastos cadastrados no sistema.
 * Permite gerar relatórios e sumarizar despesas.
 * @author Ralf
 */
public class AnaliseGastos extends javax.swing.JFrame {

    private final String caminhoLancamentos = System.getProperty("user.dir") + "/src/main/java/dados/lancamentos.csv";
    private JTable tabelaContas;


    /**
     * Creates new form AnaliseGastos
     */
    public AnaliseGastos() {
        setTitle("Análise de Gastos");
        setSize(1000, 800);
        setLocationRelativeTo(null);
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        setLayout(new BorderLayout());

        // Painel superior: gráfico de pizza e tabela lado a lado
        JPanel painelSuperior = new JPanel(new GridLayout(1, 2));

        // Gráfico de pizza
        ChartPanel painelPizza = criarPainelGraficoPizza();
        painelSuperior.add(painelPizza);

        // Tabela de contas
        tabelaContas = new JTable();
        DefaultTableModel modelo = new DefaultTableModel();
        modelo.addColumn("Conta");
        modelo.addColumn("Saldo");
        tabelaContas.setModel(modelo);
        JScrollPane scrollTabela = new JScrollPane(tabelaContas);
        painelSuperior.add(scrollTabela);

        add(painelSuperior, BorderLayout.CENTER);

        // Atualiza tabela
        atualizarTabelaContas();

        // Painel inferior: gráfico de linhas
        ChartPanel painelLinhas = criarPainelGraficoLinhas();
        add(painelLinhas, BorderLayout.SOUTH);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    
    /**
     * Cria e retorna um painel contendo um gráfico de pizza com a distribuição dos gastos
     * por categoria, baseado nos registros de despesas armazenados em um arquivo CSV.
     * <p>
     * O método realiza as seguintes etapas:
     * <ul>
     *   <li>Lê o arquivo CSV definido em {@code caminhoLancamentos};</li>
     *   <li>Filtra apenas os registros cujo tipo seja "Despesa";</li>
     *   <li>Converte os valores monetários para {@code double} (substituindo vírgula por ponto);</li>
     *   <li>Acumula os valores por categoria em um {@link Map};</li>
     *   <li>Popula o dataset do gráfico com as somas por categoria;</li>
     *   <li>Cria um gráfico de pizza usando a biblioteca {@link JFreeChart};</li>
     *   <li>Retorna um {@link ChartPanel} que pode ser exibido em uma interface Swing.</li>
     * </ul>
     *
     * <p>Em caso de erro na leitura do arquivo, uma mensagem de erro é exibida ao usuário
     * através de um {@link JOptionPane}.</p>
     *
     * @return um {@link ChartPanel} contendo o gráfico de pizza "Gastos por Categoria"
     */
    private ChartPanel criarPainelGraficoPizza() {
        DefaultPieDataset dataset = new DefaultPieDataset();
        Map<String, Double> somaPorCategoria = new HashMap<>();

        try (BufferedReader br = new BufferedReader(new FileReader(caminhoLancamentos))) {
            String linha;
            while ((linha = br.readLine()) != null) {
                String[] partes = linha.split(";");
                if (partes.length < 6) {
                    continue;
                }

                String tipo = partes[0].trim();
                String valorStr = partes[3].replace(",", ".").trim();
                String categoria = partes[4].trim();

                if (!tipo.equalsIgnoreCase("Despesa")) {
                    continue;
                }

                try {
                    double valor = Double.parseDouble(valorStr);
                    somaPorCategoria.put(categoria,
                            somaPorCategoria.getOrDefault(categoria, 0.0) + valor);
                } catch (NumberFormatException e) {
                    System.err.println("Valor inválido no CSV: " + valorStr);
                }
            }
        } catch (IOException e) {
            JOptionPane.showMessageDialog(this, "Erro ao ler o CSV: " + e.getMessage());
        }

        somaPorCategoria.forEach(dataset::setValue);
        JFreeChart graficoPizza = ChartFactory.createPieChart(
                "Gastos por Categoria",
                dataset,
                true,
                true,
                false
        );
        return new ChartPanel(graficoPizza);
    }
    
    /**
     * Atualiza a tabela de contas exibida na interface com os saldos recalculados
     * a partir dos lançamentos registrados em um arquivo CSV.
     * <p>
     * O método realiza as seguintes etapas:
     * <ul>
     *   <li>Lê o arquivo CSV definido em {@code caminhoLancamentos};</li>
     *   <li>Interpreta cada linha como um lançamento contendo tipo, valor e conta;</li>
     *   <li>Se o tipo for "Despesa", subtrai o valor do saldo da conta correspondente;</li>
     *   <li>Se for outro tipo (ex.: Receita), adiciona o valor ao saldo da conta;</li>
     *   <li>Armazena os saldos em um {@link Map}, indexados pelo nome da conta;</li>
     *   <li>Atualiza o {@link DefaultTableModel} associado à {@code tabelaContas},
     *       limpando os dados antigos e inserindo os novos saldos formatados com duas casas decimais.</li>
     * </ul>
     *
     * <p>Em caso de erro na leitura do arquivo, uma mensagem é exibida ao usuário
     * por meio de um {@link JOptionPane}.</p>
     */
    private void atualizarTabelaContas() {
        Map<String, Double> saldoPorConta = new HashMap<>();

        try (BufferedReader br = new BufferedReader(new FileReader(caminhoLancamentos))) {
            String linha;
            while ((linha = br.readLine()) != null) {
                String[] campos = linha.split(";");
                if (campos.length < 6) {
                    continue;
                }

                String tipo = campos[0].trim();
                String valorStr = campos[3].replace(",", ".").trim();
                String conta = campos[5].trim();

                try {
                    double valor = Double.parseDouble(valorStr);
                    if ("Despesa".equalsIgnoreCase(tipo)) {
                        saldoPorConta.put(conta, saldoPorConta.getOrDefault(conta, 0.0) - valor);
                    } else {
                        saldoPorConta.put(conta, saldoPorConta.getOrDefault(conta, 0.0) + valor);
                    }
                } catch (NumberFormatException e) {
                    System.err.println("Valor inválido no CSV: " + valorStr);
                }
            }
        } catch (IOException e) {
            JOptionPane.showMessageDialog(this, "Erro ao ler CSV: " + e.getMessage());
        }

        DefaultTableModel modelo = (DefaultTableModel) tabelaContas.getModel();
        modelo.setRowCount(0);
        saldoPorConta.forEach((conta, saldo) -> modelo.addRow(new Object[]{conta, String.format("%.2f", saldo)}));
    }

    /**
     * Cria e retorna um painel contendo um gráfico de linhas representando o fluxo
     * financeiro mensal (receitas, despesas e saldo), com base nos registros do arquivo CSV.
     * <p>
     * O método realiza as seguintes etapas:
     * <ul>
     *   <li>Lê o arquivo CSV definido em {@code caminhoLancamentos};</li>
     *   <li>Interpreta cada linha como um lançamento contendo tipo, valor e data;</li>
     *   <li>Converte a data para {@link LocalDate} e agrupa os valores por mês/ano;</li>
     *   <li>Soma receitas e despesas separadamente para cada mês;</li>
     *   <li>Calcula o saldo mensal (receita - despesa);</li>
     *   <li>Popula um {@link DefaultCategoryDataset} com os valores de receitas, despesas e saldo;</li>
     *   <li>Cria um gráfico de linhas usando {@link JFreeChart} e aplica configurações de renderização
     *       (exibição de pontos e rótulos nos dados);</li>
     *   <li>Configura o {@link ChartPanel} resultante com tamanho preferencial e suporte a zoom via scroll do mouse.</li>
     * </ul>
     *
     * <p>Em caso de erro na leitura do CSV, uma mensagem de erro é exibida ao usuário
     * utilizando {@link JOptionPane}.</p>
     *
     * @return um {@link ChartPanel} contendo o gráfico de linhas "Fluxo Financeiro Mensal"
     */
    private ChartPanel criarPainelGraficoLinhas() {
        DefaultCategoryDataset dataset = new DefaultCategoryDataset();
        Map<String, Double> receitasMensal = new HashMap<>();
        Map<String, Double> despesasMensal = new HashMap<>();

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");

        // Lê CSV e organiza dados mensais
        try (BufferedReader br = new BufferedReader(new FileReader(caminhoLancamentos))) {
            String linha;
            while ((linha = br.readLine()) != null) {
                String[] campos = linha.split(";");
                if (campos.length < 6) {
                    continue;
                }

                String tipo = campos[0].trim();
                String valorStr = campos[3].replace(",", ".").trim();
                String dataStr = campos[2].trim();

                LocalDate data = LocalDate.parse(dataStr, formatter);
                String mes = data.getMonthValue() + "/" + data.getYear();

                try {
                    double valor = Double.parseDouble(valorStr);
                    if ("Despesa".equalsIgnoreCase(tipo)) {
                        despesasMensal.put(mes, despesasMensal.getOrDefault(mes, 0.0) + valor);
                    } else {
                        receitasMensal.put(mes, receitasMensal.getOrDefault(mes, 0.0) + valor);
                    }
                } catch (NumberFormatException e) {
                    System.err.println("Valor inválido no CSV: " + valorStr);
                }
            }
        } catch (IOException e) {
            JOptionPane.showMessageDialog(this, "Erro ao ler CSV: " + e.getMessage());
        }

        // Preenche dataset
        for (String mes : receitasMensal.keySet()) {
            double receita = receitasMensal.getOrDefault(mes, 0.0);
            double despesa = despesasMensal.getOrDefault(mes, 0.0);
            double saldo = receita - despesa;

            dataset.addValue(receita, "Receitas", mes);
            dataset.addValue(despesa, "Despesas", mes);
            dataset.addValue(saldo, "Saldo", mes);
        }

        // Cria gráfico de linhas
        JFreeChart graficoLinhas = ChartFactory.createLineChart(
                "Fluxo Financeiro Mensal",
                "Mês",
                "Valor",
                dataset,
                PlotOrientation.VERTICAL,
                true,
                true,
                false
        );

        // Configura renderer para bolinhas e labels
        LineAndShapeRenderer renderer = new LineAndShapeRenderer();
        renderer.setDefaultShapesVisible(true);
        renderer.setDefaultItemLabelsVisible(true);
        renderer.setDefaultItemLabelGenerator(new StandardCategoryItemLabelGenerator(
                "{2}", new java.text.DecimalFormat("0.00")
        ));

        graficoLinhas.getCategoryPlot().setRenderer(renderer);

        // Painel com scroll
        ChartPanel painelLinhas = new ChartPanel(graficoLinhas);
        painelLinhas.setPreferredSize(new Dimension(1000, 300));
        painelLinhas.setMouseWheelEnabled(true); // permite zoom com scroll do mouse

        return painelLinhas;

    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> new AnaliseGastos().setVisible(true));
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
